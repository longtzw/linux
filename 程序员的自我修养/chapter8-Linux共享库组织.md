# Section1 共享库版本

# 1.1 共享库版本命名

Linux有一套规则来命名系统中的每一个共享库，它规定共享库文件名规则如下：

**libname.so.x.y.z**

'x'表示**主版本号(Major Version Number)**,'y'表示**次版本号(Minor Version Number)**,'z'表示**发布版本号(Release Version
Number)**。

**主版本号**表示库的重大升级，不同主版本号的库之间是不兼容的。

**次版本号**表示库的增量升级，即增加一些新的接口符号，且保持原来的符号不变。在主版本号相同的情况下，高次版本号的库向后兼
容第次版本号的库。

**发布版本号**表示库的一些错误的修正、性能的改进等，并不添加任何新的接口，也不对接口进行更改。相同主版本号、次版本号的共
享库，不同的发布版本号之间完全兼容。

# 1.2 SO-NAME

Linux普遍采用一种叫SO-NAME的命名机制来记录版本库的依赖关系。每个共享库都有一个对应的"SO-NAME"即共享库的文件名去掉次版本
号和发布版本号，保留主版本号。比如一个共享库叫做libfoo.so.2.6.1，那么它的SO-NAME即libfoo.so.2。很明显，"SO-NAME"规定了
共享库的接口，"SO-NAME"相同的两个共享库，次版本号大的兼容次版本号小的。系统会为每个共享库在它所在的目录创建一个跟
"SO-NAME"相同的并且指向它的**软链接(Symbol Link)**。这个软链接会指向目录中主版本号相同，次版本号和发布版本号最新的共享库
。

Linux中提供了一个工具叫做"ldconfig"，当系统中安装或更新一个共享库时，就需要运行该工具，它会遍历所有的默认共享库目录，比
如/lib, /usr/lib等，然后更新所有的软链接，使它们指向最新版的共享库；如果安装了新的共享库，那么ldconfig会为其创建相应的软
链接。

# Section2 共享库系统路径

目前大多数包括Linux在内的开源操作系统都遵守一个叫做FHS(File Hierarchy Standard)的标准，这个标准规定了一个系统中的系统文
件应该如何存放，包括各个目录的结构、组织和作用，这有利于促进各个开源操作系统之间的兼容性。

- /lib, 这个位置主要存放系统最关键和基础的共享库，比如动态连接器、C语言运行库、数学库等，这些库主要是那些/bin和/sbin下的
  程序所需要的库，还有系统启动时所需要的库。
- /usr/lib, 这个目录下主要保存的是一些非系统运行时所需要的关键性的共享库，主要是一些开发时用到共享库，这些库一般不会被用
  户程序或shell脚本直接用到。这个目录下还包含了开发时可能用到的静态库、目标文件等。
- /usr/local/lib, 这个目录用来放置一些跟操作系统本身并不十分相关的库，主要是一些第三方的应用程序库。比如我们的系统中安装
  了python语言的解释器，那么与它相关的共享库可能会被放到/usr/local/lib/python，而它的可执行文件可能被放到/lib/local/bin
  下，GNU的标准推荐第三方的程序应该默认将库安装到/usr/local/lib下。

# Section3 环境变量

通过**LD_LIBRARY_PATH**环境变量，可以临时改变某个应用程序的共享库查找路径，而不会影响系统中的其他程序。默认情况下，
LD_LIBRARY_PATH为空，如果我们为某个进程设置了LD_LIBRARY_PATH，那么进程启动时，动态链接器会首先查找LD_LIBRARY_PATH指定的
目录。

总结一下动态链接器查找共享库的顺序：

- 由环境变量LD_LIBRARY_PATH指定的路径。
- 由路径缓存文件/etc/ld.so.cache指定的路径。
- 默认共享库目录，先/usr/lib, 然后/lib。

**LD_PRELOAD**环境变量，可以指定预先装载的一些共享库或是目标文件。在LD_PRELOAD里面指定的文件会在动态连接器按照固定的规则
搜索共享库之前装载，它比LD_LIBRARY_PATH里面指定的目录中的共享库还要有限。无论程序是否依赖于它们，LD_PRELOAD里面指定的共
享库或目标文件都会被装载。

由于全局符号介入这个机制的存在，LD_PRELOAD里面指定的共享库或目标文件中的全局符号就会覆盖后面加载的同名全局符号，这使得我
们可以很方便地做到改写标准C库中的某个或某几个函数而不影响其他函数，对于程序的调试或测试非常有用。系统配置文件中有一个文
件是/etc/ld.so.preload, 它的作用于LD_PRELOAD一样。

**LD_DEBUG**环境变量可以打开动态链接器的调试功能，当我们设置这个环境变量时，动态链接器会在运行时打印出各种有用的信息。

# Section4 共享库的创建和安装

## 4.1 共享库的创建

比如我们有lobfoo1.c和libfoo2.c两个源代码文件，希望产生一个libfoo.so.1.0.0的共享库，这个共享库依赖于libbar1.so和
libbar2.so这两个共享库，我们可以使用以下命令行：

```
gcc -shared -fPIC -Wl, -soname, libfoo.s0.1 -0 libfoo.so.1.0.0 libfoo1.c libfoo2.c -lbar1 -lbar2
```
"-shared"表示输出结果为共享库类型。

"-fPIC"表示使用地址无关代码技术来产生输出文件。

"-Wl"可以将指定的参数传递给链接器，"-soname libfoo.so.1"用于输出共享库的SO-NAME。

**注意：如果我们不使用-soname来指定共享库的SO-NAME，那么该共享库默认就没有SO-NAME，即使用ldconfig更新SO-NAME的软链接时，
对该共享库没有效果**

链接器的"-rpath"参数可以指定链接产生的目标程序的共享库查找路径，效果等同于设置LD_LIBRARY_PATH。

链接器的"-export-dynamic"参数，可以在生成可执行文件时，将所有全局符号导出到动态符号表。

## 4.2 清除符号信息

除了使用"strip"工具，我们还可以使用ld的"-s"和"-S"参数，使得链接器生成输出文件时不产生符合信息。"-s"和"-S"的区别是: "-S"
消除调试符号信息，而"-s"消除所有符号信息。

## 4.3 共享库的安装

最简单的方法就是将共享库复制到某个标准的共享目录，如/lib, /usr/lib等，然后运行ldconfig即可。如果没有root权限，则无法往
/lib, /usr/lib等目录添加文件，也无法运行ldconfig程序。这时需要将共享库放在其他共享目录，并在使用ldconfig时指定共享目录。

```
ldconfig -n shared_library_directory
```

## 4.4 共享库构造和析构函数

很多时候我们希望共享库在被加载时能够进行一些初始化工作，比如打开文件、网络连接等，使得共享库里的函数接口能够正常工作。
GCC提供了一种共享库的构造函数，只要在函数声明时加上"__attribute__((constructor))"的属性。与构造函数对应的是析构函数，我
们可以在函数声明时加上"__attribute__((destructor))__属性"。

**注意：__attribute__语法是GCC对C和C++语言的扩展，在其他编译器上这种语法并不通用**

