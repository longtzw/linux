# Section1 为什么要动态链接

- 静态库在被多个进程调用时，存在多个副本，浪费内存空。
- 静态库对程序的更新，部署和发布也会带来很多麻烦。
- 动态链接可以在程序运行时动态地选择加载各种程序模块，增加了程序的可扩展性和兼容性。

将链接这个过程推迟到了运行时再进行，是动态链接的基本思想。

在Linux系统中，ELF动态链接文件被称为动态共享对象(DSO, Dynamic Shared Objects)，它们一般都是以".so"为扩展名。

```
gcc -fPIC -shared -o Lib.so Lib.c
```
参数"-shared"表示产生共享对象，参数"-fPIC"用于产生地址无关的代码。

动态链接器与普通共享对象一样被映射到了进程的地址空间，在系统开始运行进程之前，首先会把控制权交给动态连接器，
由它完成所有的动态链接工作后再把控制权交给进程，然后开始执行。

# Section2 地址无关代码

共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。与此不同的是，可执行文件基本可以确定自己在进程虚拟
地址空间中的其实位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定的空闲地址，比如Linux下一般
是0x0804000，Windows下一般是0x0040000。

装载时重定位是解决动态模块中有绝对地址引用的办法之一，但是它有一个很大的缺点是指令部分无法再多个进程间共享。
另一种方案被称为地址无关代码(PIC,Position-independent Code)，其基本想法就是将指令中哪些需要被修改的部分分离出来，
跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。

一个使用装载时重定位的共享对象，不能被多个进程使用，但运行速度比使用地址无关代码的共享对象快，因为它省去了地址
无关代码中每次访问全局数据和函数时需要做一次计算当前地址以及间接地址寻址的过程。

全局偏移表(Global Offset Table, GOT)

ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块中的全局变量，通过GOT来实现变量的访问。

# Section3 延迟绑定(PLT)

据统计ELF程序在静态链接下要比动态库稍微快一点，大约为1%~5%。动态链接比静态链接慢的主要原因是动态链接下对全局
和静态变量的当问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先定位GOT，然后在进行间接跳转。

在一个程序运行过程中，可能很多函数在程序执行完毕时都不会被用到，如果一开始就把所有函数链接好实际上是一种浪费，
ELF采用了一种叫延迟绑定(Lazy Binding)的做法。基本思想是当**函数第一次被用到时才进行绑定**，如果没有用到就不进行
绑定。ELF使用PLT(Procedure Linkage Table)的方法实现。

# Section4 动态链接相关结构

## 4.1 ".interp"段

在动态链接的ELF可执行文件中，有一个".interp"段指定了动态链接器的位置。

## 4.2 ".dynamic"段

这个段保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、
共享对象初始化代码的地址。其结构定义在"elf.h"中。

可以通过如下命令查看".dynamic"段的内容:

```
readelf -d libxx.so
```

如下命令可用来查看一个程序主模块或一个共享库依赖于哪些共享库：

```
ldd program
```

## 4.3 动态符号表

为了表示动态链接模块间的符号导入导出关系，ELF专门有一个叫做**动态符号表(Dynamic Symbol Table)**的段用于保存这些信息。
段名叫".dynsym"(Dynamic Symbol)。与".symtab"不同，".dynsym"只保存了与动态链接相关的符号。很多时候动态链接的模块同时
拥有".dynsym"和".symtab"两个表，后者往往保存了所有符号，包括前者中的符号。

与".symtab"类似，动态符号表也需要一些辅助的表，比如用于保存符号名的**动态符号字符串表**".dynstr"(Dynamic String Table)
，用于加快符号查找的**符号哈希表**".hash"。

## 4.4 动态链接重定位表

对于使用了PIC技术的可执行文件或共享对象来说，虽然代码段不需要重定位，但数据段还包含了绝对地址引用，因为代码段中绝对地址
引用的部分被分离出来，变成了GOT，而GOT实际上是数据段的一部分。

在静态链接中，".rel.text"表示代码段的重定位表，".rel.data"是数据段的重定位表。在动态链接的文件中，也有类似的重定位表，
分别叫做".rel.dyn"和".rel.plt"。

# Section5 动态链接的步骤和实现

## 5.1 动态链接器自举

## 5.2 装载共享对象

当一个新的共享对象被装载进来时，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里将
包含进程中所有动态链接所需的符号。

一个共享对象里面的全局符号可能被另一个共享对象中的同名全局符号覆盖的现象被称为**全局符号介入**(Global Symbol Interpose)
。Linux下动态链接器的处理是**当一个符号需要被加入全局符号表时，如果相同的符号名已存在，则后加入的符号被忽略**。当程序使
用大量共享对象时应该非常小心符号的重名问题，如果两个符号重名又执行不同的功能，那么程序运行时可能将所有该符号名的引用解析
到第一个被加入全局符号表的使用该符号名的符号，从而导致程序莫名其妙的错误。

## 5.3 重定位和初始化

# Section6 显式运行时链接

支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做**显式运行时链接**(Explicit Run-time Linking)，有时候也叫做
**运行时加载**。也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块式将其卸载。
