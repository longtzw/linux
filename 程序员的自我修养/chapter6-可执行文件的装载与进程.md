# Section1 进程虚拟地址空间

程序(或者狭义上讲可执行文件)是一个静态的概念，它就是一些预先编译好的指令和数据集合的一个文件；进程则是一个动态的概念，它
是程序运行时的一个过程。

每个程序被运行起来以后，都拥有自己独立的虚拟地址空间(Virtual Address Space)，该空间大小由CPU位数决定。理论上32位平台下，
每个进程拥有4GB虚拟空间。但程序运行时处于操作系统的监管下，进程智能使用操作系统分配的地址。如果访问了未经允许的空间，那
么操作系统会捕获到这些访问，将进程的这种访问当作非法操作，强制结束进程。

以Linux操作系统为例，整个4GB被划分成两部分，0xC0000000~0xFFFFFFFF(操作系统本身, 1GB)，0x00000000~0xBFFFFFFF(进程使用，
3GB)。

# Section2 从操作系统角度看可执行文件的装载

## 2.1 进程的建立

在有虚拟存储的情况下，创建一个进程最开始只需做三件事：

- 创建一个独立的虚拟地址空间。
- 读取可执行文件头，并且建立虚拟空间和可执行文件的映射关系。
- 将CPU的指令寄存器设置为可执行文件的入口地址，启动运行。

我们知道一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，所以创建一个虚拟空间实际上并不是创建空间而是
创建映射函数所需要的相应的数据结构。

读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，
然后将该"缺页"从磁盘中读取到内存中，再设置缺页和物理页的映射关系，这样程序才得以正常运行。

# Section3 进程虚拟存储空间分布

## 3.1 ELF文件的执行视图和链接视图

ELF可执行文件引入一个概念叫做"Segment"， 一个"Segment"包含一个或多个属性类似的"Section"。从链接的角度看，ELF文件是按
"Section"存储的；从装载的角度看，ELF文件又可以按照"Segment"存储。装载时，将属性类型的"Section"合并成一个"Segment"，可以
减少内存的浪费。

Linux中将进程虚拟空间中的一个Segment叫做**虚拟内存区域(VMA, Virtual Memory Area)**，VMA时一个很重要的概念。它对我们理解
程序的装载执行和操作系统如何管理进程的虚拟空间有非常重要的帮助。

"Segment"和"Section"是从不同的角度来划分同一个ELF文件。这个在ELF中被称为不同的视图(View)，从"Section"的角度来看ELF文件就
是**链接视图(Link View)**，从"Segment"的角度来看就是**执行视图(Execution View)**。

ELF可执行文件中有一个专门的数据结构叫做**程序头表(Program Header Table)**用来保存"Segment"的信息。因为ELF目标文件不需要
被装载，所以它没有程序头表。

## 3.2 堆和栈

**maps文件说明**

00008000-00035000 r-xp 00000000 1f:06 440        /program/bin/iwareserver

第一列是VMA的地址范围；第二列是VMA的权限，"r"表示可读，"w"表示可写，"x"表示可执行，"p"表示私有的，"s"表示共享的；第三列
是偏移，表示VMA对应的Segment在映像文件中的偏移；第四列表示映像文件所在设备的主设备号和次设备号；第五列表示映像文件的节点
号；最后一列是映像文件的路径。

0003e000-00521000 rw-p 00000000 00:00 0          heap
beaae000-beacf000 rw-p 00000000 00:00 0          stack
ffff0000-ffff1000 r-xp 00000000 00:00 0          vectors

上面三个Segment的文件所在设备主设备号和次设备号及文件节点号都是0，表示它们没有映射到文件中，这种VMA叫做**匿名虚拟内存区
域(Anonymouns Virtual Memory Area)**，vectors是一个很特殊的VMA，它位于内核空间，事实上它是内核的一个模块，进程可以通过它
与内核进行通信。

# Segment4 Linux内核装载ELF过程简介

首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，原先的
bash进程继续返回等待刚启动的新进程结束，然后继续等待用户输入命令。

在进入execve()系统调用之后，Linux内核就开始真正的装载工作了。在内核中，execve()系统调用相应的入口时sys_execve()，
sys_execve()进行一些参数的检测复制后，调用do_execve()。do_execve()会首先查找被执行的文件，如果找到文件，则读取文件的前
128个字节，用于判断文件格式。没种可执行文件开头几个字节很特殊，特别是前4个字节(**魔数**)，通过它可以确定文件的格式和类型
。


